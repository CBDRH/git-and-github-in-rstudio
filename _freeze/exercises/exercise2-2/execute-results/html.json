{
  "hash": "9b2fb363da660ac13183750d3b785b2e",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Step-by-step guide\"\nformat: \n  html:\n    execute:\n      echo: true\n      eval: false \nnumber-sections: true  \n---\n\n\n# Set up your code file meta data\n\nAs before, you should your code file with some meta information in the form of commented out text.\n\n::: aside\n@hint-meta\n:::\n\n::: {style=\"display: none;\"}\n::: {#hint-meta}\nInclude similar information to last time: the project name and purpose, and the code inputs and outputs.\n:::\n:::\n\n<hr>\n\n# Load libraries\n\nLoad all of your libraries in a single location at the top of the file.\n\n::: aside\n@hint-libraries\n:::\n\n::: {style=\"display: none;\"}\n::: {#hint-libraries}\nStart with the three libraries from the last exercise: `readxl`, `dplyr`, and `tidyr`.\n:::\n:::\n\n<hr>\n\n# Commit your changes\n\nRemember it is good practice to commit your changes regularly. You can do that now.\n\n::: aside\n@hint-git\n:::\n\n::: {style=\"display: none;\"}\n::: {#hint-git}\nThis isn't essential but it's good to get into the practice. You don't have to push every time you commit.\n:::\n:::\n\n<hr>\n\n# Download the data locally\n\nDownload the raw data using the ABS website link below and the `download.file()` function.\n\n<https://www.abs.gov.au/statistics/health/health-conditions-and-risks/national-health-survey/2022/NHSDC01.xlsx>\n\n::: aside\n@hint-download\n:::\n\n::: {style=\"display: none;\"}\n::: {#hint-download}\nUse the same code as before. Remember to update the URL and destination file name.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Spreadsheet url\nmyURL <- \" \"\n\n# Download the file locally\ndownload.file(\n  url = , \n  destfile = \" \")\n```\n:::\n\n:::\n:::\n\n::: callout-caution\n## Checkpoint\n\nYou should see the `.xlsx` spreadsheet downloaded into your **raw-data** folder.\n:::\n\n<hr>\n\n# Read in the data to R\n\nRead in the raw data from the sheet **Table 1.3_Proportions** using the `read_excel()` function. Remember the same key arguments from last time:\n\n-   **path** Where you have downloaded the excel file\n-   **sheet** The sheet you want to read from\n-   **skip** The number of lines to skip before reading\n-   **.name_repair** the function to make names unique\n\n::: aside\n@hint-read\n:::\n\n::: {style=\"display: none;\"}\n::: {#hint-read}\nUse the same code as before. Check in the excel file how many rows you want to skip so that the years (2001 2004â€“05 etc) are the first row of data.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Read in the raw data\ndf2Raw <- read_excel(\n  path = \" \",\n  sheet = \" \",\n  skip = ,\n  .name_repair =  \n)\n```\n:::\n\n:::\n:::\n\n::: callout-caution\n## Checkpoint\n\nYou should be able to see the data frame in your R Environment pane. Check that it has 130 rows and 15 variables.\n:::\n\n<hr>\n\n# Subset to the 12 rows with data on chronic conditions\n\nStart your data cleaning by filtering to the rows that contain the chronic conditions (arthritis, asthma etc). These should be in rows 12 to 23 (but check in your data).\n\n::: aside\n@hint-slice\n:::\n\n::: {style=\"display: none;\"}\n::: {#hint-slice}\nUse the `slice()` function to subset to the rows you need, for example, this would subset to rows 4 to 6.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Clean the raw data\ndf2Clean <- df2Raw |>\n  slice(4:6)\n```\n:::\n\n:::\n:::\n\n::: callout-caution\n## Checkpoint\n\nYour dataframe should have 12 rows, one for each chronic condition.\n:::\n\n<hr>\n\n# Select the columns of interest\n\nSelect the first column (with the chronic conditions) and the columns with age-standardised proportions. If you specified `.name_repair = ~ make.names(.x, unique = TRUE)` then the columns with age-standardised proportions will all end with `.1`.\n\n::: aside\n@hint-select\n:::\n\n::: {style=\"display: none;\"}\n::: {#hint-select}\n\nAs before, use `select()` to select the variables you want to keep. `ends_with()` is a useful function to select multiple variables with the same name.\n\nFor example, this would select the variables `species`, `bill_length_mm` and `flipper_length_mm` from the `penguins` dataset. \n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Select\nlibrary(palmerpenguins)\n\npenguins |> \nselect(c(species, ends_with(\"length_mm\")))\n```\n:::\n\n:::\n:::\n\n::: callout-caution\n## Checkpoint\n\nYour dataframe should have 8 variables: the column of chronic conditions and the 7 date columns.\n:::\n\n<hr>\n\n# Pivot from wide format to long format\n\nCurrently we are in wide format, with one column for each survey period, and the proportions in the cells. We need to move to long format with a single column for the survey period and a single column for the percentages. \n\nWe can achieve this using `pivot_longer()`. Remember, there are a few important arguments: \n\n* **cols** The variables we want to stack when we move from wide to long, i.e. the variables that are the survey periods ending in `.1`.\n* **names_to** The name of the new variable containing the survey periods.\n* **values_to** The name of the new variable containing the percentages\n\n::: aside\n@hint-pivot\n:::\n\n::: {style=\"display: none;\"}\n::: {#hint-pivot}\n\nThis step is tricky. If you copied the approach from last time you may well have encountered the error **! Can't combine `X2001.1` <character> and `X2022.1` <double>**\n\nThis arises because some of the columns were read in as numeric while others were read in as character (the character columns had the text \"na\" somewhere in the original spreadsheet). Trying to stack character variables on top of numeric variables causes problems.  \n\nTo get around this, we need to add the `values_transform = as.numeric` argument in `pivot_longer()`. This argument makes sure all of the variables are numeric when they are stacked.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Pivot longer\npivot_longer(\n  cols = ends_with(\".1\"),\n  names_to = 'period',\n  values_to = 'percent',\n  values_transform = as.numeric) \n```\n:::\n\n:::\n:::\n\n::: callout-caution\n## Checkpoint\n\nAll going well you should have 84 rows (12 conditions $\\times$ 7 survey periods) and three columns: `X`, `period` and `percent.`\n\nDon't worry if you get a warning message about NAs. Some of the time series are missing data, for example there is no data point for diabetes in 2004-05.  \n:::\n\n<hr>\n\n# Rename the variable `X`\n\nWe still have the unsightly variable name `X`. Go ahead and rename it to `condition.` \n\n::: aside\n@hint-rename\n:::\n\n::: {style=\"display: none;\"}\n::: {#hint-rename}\nRemember the syntax\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Rename\nrename(newName = oldName)\n```\n:::\n\n:::\n:::\n\n::: callout-caution\n## Checkpoint\n\nYou're doing great!\n:::\n\n<hr>\n\n# Tidy up the `period` variable\n\nThis is a tricky step so the full solution is outlined below. Among other things we encounter dates for the first time.\n\nThe `period` variable refers to the survey period, but it is a bit of a disaster with entries like **X2001.1** and **X2004.05.1**. We need to tidy it up to have nicely formatted dates instead of these weird strings. \n\n::: aside\n@hint-period\n\n:::\n\n::: {style=\"display: none;\"}\n::: {#hint-period}\n\n![That was pretty full on so there is no hint beyond the code in the instructions. You got this like Molly got her ball.](../images/molly-ball.jpeg)\n\n:::\n:::\n\nReferring back to the original spreadsheet, these dates refer to single calendar years (for 2001 and 2022) and multiple calendar years like 2004-05 and 2007-08.\n\nWhile the survey collection period naturally spanned months or years, for the purpose of plotting we want to be able to choose a single date. For whole years, we will choose the mid-year point i.e. July 1. For survey periods that spanned multiple years we will choose the first day of the second year, i.e. January 1. To summarise, we want to assign the survey periods to specific dates as follows. \n\n* 2001 $\\rightarrow$ 01/07/2001\n* 2004-05 $\\rightarrow$ 01/01/2005\n* 2007-08 $\\rightarrow$ 01/01/2008\n* 2011-12 $\\rightarrow$ 01/01/2012\n* 2014-15 $\\rightarrow$ 01/01/2015\n* 2017-18 $\\rightarrow$ 01/01/2018\n* 2022 $\\rightarrow$ 01/07/2022\n\nWe could hard code this, but noticing there are only two date formats we can also use an `ifelse()` function, with one rule for single year dates like **X2001.1** and a second rule for multiple year dates like **X2004.05.1**\n\nHere's what the code looks like.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n  mutate(\n    date = as.Date(\n      ifelse(nchar(period)==7,\n             paste(as.numeric(substr(period, 2, 5)), '07', '01', sep='-'),\n             paste(as.numeric(substr(period, 2, 5)) + 1, '01', '01', sep='-'))\n    ))\n```\n:::\n\n\nThere's a few things going on so let's break it down. \n\n* We start with `mutate(date = as.Date(...))` to create a new variable named `date` that has a date format. The `as.Date()` function converts strings that look like dates to actual Date objects in R. Try entering `as.Date(\"2024-11-21\")` in the console for example. \n\n* Inside the `as.Date()` function we are calling `ifelse()`. The logical condition that is tested is whether the period string has 7 characters. So this will be `TRUE` for the string **X2001.1** but false for the string **X2004.05.1**. You can test this yourself by entering `nchar(\"X2001.1\")` at the console.\n\n* For dates like **X2001.1** the rule is `paste(as.numeric(substr(period, 2, 5)), '07', '01', sep='-')`. This extracts the year and combines it with the strings \"07\" and \"01\", separated by \"-\". The result is something like \"2001-07-01\". To see this in action, try entering `paste(as.numeric(substr(\"X2001.1\", 2, 5)), '07', '01', sep='-')` at the console. \n\n* For dates like **X2004.05.1** the rule is `paste(as.numeric(substr(period, 2, 5)) + 1, '01', '01', sep='-')`. This extracts the first year, adds 1 then combines it with the strings \"01\" and \"01\", separated by \"-\". The result is something like \"2005-01-01\". To see this in action, try entering `paste(as.numeric(substr(\"X2007.08.1\", 2, 5)) + 1, '01', '01', sep='-')` at the console. \n\n\n::: callout-caution\n## Checkpoint\n\nIf run successfully, you should now have a new variable named date, which is also formatted as a date object. You can test this by entering is the `is.Date()` function from the `lubridate` package. Try entering the following at the console.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlubridate::is.Date(df2Clean$date)\n```\n:::\n\n\n\n:::\n\n<hr>\n\n# Tidy up the `condition` variable\n\nThe categories of the chronic conditions still include footnotes, like **Arthritis(d)**, or long names like **Cancer (malignant neoplasms)**. When we come to plot these we are going to want the labels to be relatively short so we will tidy these up now. \n\nUse `mutate()` and `case when()` to create shorter and tidier category names for the condition variable. \n\n::: aside\n@hint-condition\n:::\n\n::: {style=\"display: none;\"}\n::: {#hint-condition}\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmutate(\n    condition = case_when(\n      condition==\"Arthritis(d)\" ~ \" \",\n      condition==\"Asthma\" ~ \" \",\n      condition==\"Back problems (dorsopathies)(e)\" ~ \" \",\n      condition==\"Cancer (malignant neoplasms)\" ~ \" \",\n      condition==\"Chronic obstructive pulmonary disease (COPD)(f)\" ~ \" \",\n      condition==\"Diabetes mellitus(g)\" ~ \" \",\n      condition==\"Hayfever and allergic rhinitis\" ~ \" \",\n      condition==\"Heart, stroke and vascular disease(h)\"  ~ \" \",\n      condition==\"Hypertension(i)\" ~ \" \",\n      condition==\"Kidney disease(j)\" ~ \" \",\n      condition==\"Mental and behavioural conditions(k)(l)(m)\" ~ \" \",\n      condition==\"Osteoporosis(n)\" ~ \" \"\n    )\n  )\n```\n:::\n\n:::\n:::\n\n::: callout-caution\n## Checkpoint\n\nIf you view your dataframe, the categories in the updated condition name should look short and neat. You can check the length of the longest variable by pasting the code below at the console. \n\n\n::: {.cell}\n\n```{.r .cell-code}\nmax(nchar(df2Clean$condition))\n```\n:::\n\n\n\n:::\n\n<hr>\n\n# Drop the old variable `period`\n\nNow that we have a nicely formatted `date` variable we won't need the old variable `period` so go ahead and drop that.\n\n::: aside\n@hint-drop\n:::\n\n::: {style=\"display: none;\"}\n::: {#hint-drop}\nRemember to drop a variable you can use `select()` with `-` in front of the variable name. For example this would drop the variable `speed` from the cars dataset. \n\n\n::: {.cell}\n\n```{.r .cell-code}\ncars |> \n  select(-speed)\n```\n:::\n\n:::\n:::\n\n::: callout-caution\n## Checkpoint\n\nYour tidy dataset should have 84 rows and three variables: `condition`, `date`, and `percent`. \n\n:::\n\n<hr>\n\n# Save the clean dataset\n\nAmazing, you made it! The final step is to save the clean dataset locally. We can follow the code from Exercise 1 to save it in both `.Rda` and `.csv` format, using `save()` and `write.csv()` respectively.\n\n::: aside\n@hint-save\n:::\n\n::: {style=\"display: none;\"}\n::: {#hint-save}\n\nFollow the code from last time, but remember to update the file names!\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Save the data in .Rda format\nsave(XXX, file = )\n\n# Save the data in .csv format\nwrite.csv(XXX,\n          file = ),\n          row.names = FALSE)\n```\n:::\n\n:::\n:::\n\n::: callout-caution\n## Checkpoint\n\nYour tidy dataset should have 84 rows and three variables: `condition`, `date`, and `percent`. \n\n:::\n\n<hr>\n\n::: {style=\"margin: 0 auto;\"}\n\nCongratulations, you made it!! \n\n<iframe src=\"https://giphy.com/embed/l0unkiodQqmA3lPO5e\" width=\"480\" height=\"269\" style=\"\" frameBorder=\"0\" class=\"giphy-embed\" allowFullScreen></iframe><p><a href=\"https://giphy.com/gifs/Dogtopia-good-job-success-you-rock-l0unkiodQqmA3lPO5e\">via GIPHY</a></p>\n\n:::",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}